/*
 * UByte - Unsigned Byte class
 * Copyright (c) 2015 Gary Hammock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package GUJO;  // Gary's Unsigned Java Objects.

/**
 * This class seeks to implement the unsigned byte object that was
 * (wrongly) excluded from the Java language.
 *  
 * @author Gary Hammock, PE
 * @since 2015-03-06
 * @version 1.0.0
 */
public final class UByte extends Number implements Comparable<UByte>{
    
    /**
     * A UID Generated by Eclipse.  (Required to extend java.lang.Number).
     */
    private static final long serialVersionUID = 1188939977661718941L;

    /******************************************************
    **                   Constructors                    **
    ******************************************************/
    
    /**
     * Empty constructor.
     */
    public UByte () {
        _value = 0x00;
    }
    
    /**
     * Initializer constructor using a byte primitive.
     * 
     * @param value The 8-bit value to use as the initial value.
     */
    public UByte (byte value) {
        
        // We need to do some bit-twiddling if the MSB is high so we don't
        // store a negative value.
        if ((value & 0x80) == 1) {
            _value = (short)(value & 0x7f);
            _value |= 0x80;
        }
        else {
            _value = value;
        }
    }  // End constructor UByte(byte).
    
    /**
     * Initializer constructor using a short integer value.
     * 
     * @param value A 16-bit short integer that is used as the initial value.
     */
    public UByte (short value) {
        _value = (short)(value & 0x00ff);
    }
    
    /**
     * Initializer constructor using an integer value.
     * 
     * @param value A 32-bit integer that is used as the initial value.
     */
    public UByte (int value) {
        _value = (short)(value & 0x000000ff);
    }
    
    /**
     * Initializer constructor using a long integer value.
     * 
     * @param value A 64-bit integer that is used as the initial value.
     */
    public UByte (long value) {
        _value = (short)(value & 0x00000000000000ff);
    }
    
    /******************************************************
    **               Accessors / Mutators                **
    ******************************************************/
    
    /**
     * Returns an 8-bit demoted value of the unsigned byte.
     * 
     * @return An 8-bit byte primitive.
     */
    public byte byteValue () {
        return (byte)(_value & 0xff);
    }
    
    /**
     * Retrive a 16-bit primative type with the value.
     * 
     * @return A 16-bit short integer of the unsigned byte's value.
     */
    public short shortValue () {
        return _value;
    }
    
    /**
     * Returns the 32-bit promoted value of the unsigned byte.
     * 
     * @return A 32-bit integer primitive of the value.
     */
    public int intValue () {
        return (int)_value;
    }
    
    /**
     * Return a 64-bit promoted value of the unsigned byte.
     * 
     * @return A 64-bit integer primative of the value.
     */
    public long longValue () {
        return (long)_value;
    }
    
    /**
     * Return a single-precision promoted float value of the unsigned byte.
     * 
     * @return A float primative of the value.
     */
    public float floatValue () {
        return (float)_value;
    }
    
    /**
     * Return a double-precision promoted float value of the unsigned byte.
     * 
     * @return A double primative of the value.
     */
    public double doubleValue () {
        return (double)_value;
    }
    
    /**
     * Retrieve the value of the UByte object as a string.
     */
    public String toString () {
        return Short.valueOf(_value).toString();
    }
    
    /**
     * Retrive the hash code of the UByte object.
     */
    public int hashCode () {
        return Short.valueOf(_value).hashCode();
    }
    
    /**
     * Set the value of the unsigned byte object to a given value.
     * 
     * @param value The value that is to be assigned to the object. 
     */
    public void assign (byte value) {
        if (value < MIN_VALUE)
            _value = (short)((value & 0x7f) | 0x80);
        else
            _value = (short)(value & 0xff);
    }
    
    /**
     * Set the value of the unsigned byte object to a given value.
     * 
     * @param value The value that is to be assigned to the object. 
     */
    public void assign (short value) {
        _value = (short)(value & 0x00ff);
    }
    
    /**
     * Set the value of the unsigned byte object to a given value.
     * 
     * @param value The value that is to be assigned to the object. 
     */
    public void assign (int value) {
        _value = (short)(value & 0x000000ff);
    }
    
    /**
     * Set the value of the unsigned byte object to a given value.
     * 
     * @param value The value that is to be assigned to the object. 
     */
    public void assign (long value) {
        _value = (short)(value & 0x00000000000000ff);
    }
    
    /**
     * Compare two UByte objects for equivalence.
     * 
     * @param toCompare The RHS UByte object that is to be compared to
     *                  the calling UByte object.
     * @return true if the two objects are equal, false otherwise.
     */
    public boolean equals (Object toCompare) {
        if (this == toCompare)
            return true;
        else if (toCompare instanceof UByte) {
            if ((_value & 0x00ff) == (((UByte)toCompare)._value & 0x00ff))
                return true;
            else
                return false;
        }
        else
            return false;        
    }
    
    /**
     * Compare the value of a caller to another UByte object's value.
     * 
     * @param anotherByte The UByte object whose value is to be compared.
     * @return A value of 0 if the values of the two UBytes are equivalent;
     *         a value less than 0 if the calling object is less than the
     *         compared object; or a value greater than 0 if the caller is
     *         greater than the compared object.
     */
    public int compareTo (UByte anotherByte) {
        if (_value < anotherByte._value)
            return -1;
        else if (_value == anotherByte._value)
            return 0;
        else
            return 1;
    }
    
    /**
     * Left shift the UByte object by a given number of positions.
     * 
     * @param positions The number of bits to shift [0, 8].
     * @return A new UByte object with the shifted value.
     */
    public UByte leftShift (int positions) {
        
        // Force a negative input to output the current value
        // as though it were invalid.
        if (positions < 0)
            return new UByte(_value);
        
        // Anything that is greater than 8 positions will always result
        // in shifting all bits out of the byte leaving a value of 0x00.
        if (positions > 8)
            return new UByte(0x00);
        
        UByte output = new UByte(_value);
        output._value <<= positions;
        
        output._value &= 0xff;
        
        return output;
        
    }  // End method leftShift().
    
    /**
     * Right shift the UByte object by a given number of positions.
     * 
     * @param positions The number of bits to shift [0, 8].
     * @return A new UByte object with the shifted value.
     */
    public UByte rightShift (int positions) {
        
        // Force a negative input to output the current value
        // as though it were invalid.
        if (positions < 0)
            return new UByte(_value);
        
        // Anything that is greater than 8 positions will always result
        // in shifting all bits out of the byte leaving a value of 0x00.
        if (positions > 8)
            return new UByte(0x00);
        
        UByte output = new UByte(_value);
        output._value >>>= positions;
        
        output._value &= 0xff;
        
        return output;
        
    }  // End method rightShift().
    
    /**
     * Left circular shift the UByte object by a given number of positions.
     * 
     * @param positions The number of bits to shift [0, 8].
     * @return A new UByte object with the shifted value.
     */
    public UByte leftCircularShift (int positions) {
        
        // Force a negative input to output the current value
        // as though it were invalid.
        if (positions < 0)
            return new UByte(_value);
        
        positions %= 8;
        
        UByte output = new UByte(_value);
        output._value = (short)((_value << positions)
                       | (_value >>> (8 - positions)));
        
        output._value &= 0xff;
        
        return output;
        
    }  // End method leftShift().
    
    /**
     * Right circular shift the UByte object by a given number of positions.
     * 
     * @param positions The number of bits to shift [0, 8].
     * @return A new UByte object with the shifted value.
     */
    public UByte rightCircularShift (int positions) {
        
        // Force a negative input to output the current value
        // as though it were invalid.
        if (positions < 0)
            return new UByte(_value);
        
        positions %= 8;
        
        UByte output = new UByte(_value);
        output._value = (short)((_value >>> positions)
                       | (_value << (8 - positions)));
        
        output._value &= 0xff;
        
        return output;
        
    }  // End method rightShift().
    
    /******************************************************
    **            Public Members / Fields                **
    ******************************************************/
    
    public static final short MAX_VALUE = 0xff;
    public static final short MIN_VALUE = 0x00;
    public static final short SIZE = 0x08;
    public static final Class<UByte> TYPE = UByte.class;
    
    /******************************************************
    **                 Private Members                   **
    ******************************************************/
    
    /**
     * The internal value of the unsigned byte object.
     */
    private short _value;

}  // End class UByte.
